/** Segunda mision del nao
	Agreguemos ahora algun evento no controlable:
	Cuando el Nao este listo para escuchar (evento no controlable) va a prender la luz, cuando ya no pueda escuchar la va a apagar.
*/

LucesCabeza = LucesApagadas,
LucesApagadas = (luces_cabeza_on -> LucesPrendidas),
LucesPrendidas = (luces_cabeza_off -> LucesApagadas).

ModuloMovimiento = MoveStart,
MoveStart = (move -> MoveEnd),
MoveEnd = (move_end -> MoveStart).

ModuloPerfilar = Q0,
Q0 = (perfilar -> (ok -> Q0 | not_ok -> Q0)).

ModuloPedir = Q0,
Q0 = (pedir -> Q1),
Q1 = (no_operation -> Q1).

// Siempre iniciamos con la accion controlable "sensar_escucha" para no ser inundados por las no controlables.
SensorDistancia = Q0,
Q0 = (move_end -> sensar_distancia -> (cerca -> Q0 | lejos -> Q0)).

// Que modulos componen al Nao?
||Nao = (ModuloPerfilar || ModuloMovimiento || SensorDistancia || ModuloPedir).

set Controlables = {move, pedir, perfilar, sensar_distancia, no_operation}
set Alphabet = {Controlables, cerca, lejos, ok, not_ok, move_end}


fluent SensorDistancia = <sensar_distancia, Alphabet \ {sensar_distancia}> initially 0
fluent EstoyCerca = <cerca, lejos> initially 0

fluent YaPedi = <pedir, Alphabet \ Alphabet> initially 0
fluent EstoyPerfilado = <ok, {perfilar, move_end}> initially 0

ltl_property SiMoviEntoncesEstoyPerfilado = [](move -> EstoyPerfilado)
ltl_property SiPediEntoncesEstoyCerca = [](pedir -> EstoyCerca)
ltl_property NoPerfilesPostGoal = [](perfilar -> !YaPedi)


fluent LEJOS = <lejos, Alphabet \ {lejos}>
assert A_LEJOS = LEJOS

fluent NOK = <not_ok, Alphabet \ {not_ok}>
assert A_NOK = NOK



controllerSpec ControlSpec = {
	safety = {SiMoviEntoncesEstoyPerfilado, SiPediEntoncesEstoyCerca, NoPerfilesPostGoal}
	assumption = {}
	failure = {A_LEJOS, A_NOK}
	liveness = {YaPedi}
	controllable = {Controlables}
}

controller ||Controller = (Nao)~{ControlSpec}.
minimal ||UPDATE_CONTROLLER = (Nao || Controller).
